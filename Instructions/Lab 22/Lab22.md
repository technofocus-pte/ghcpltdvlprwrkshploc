**实验室 21 - 使用 .NET 创建最小 WebAPI 和使用 GitHub Copilot 的相应
Docker 映像**

**目的：**

目标是在 GitHub Copilot 的帮助下使用 .NET 7.0 创建最小 WebAPI 和相应的
Docker 映像。在这里，我们尽可能多地使用 GitHub Copilot。

尝试不同的事情，看看 GitHub Copilot 可以为您做什么，例如生成 Dockerfile
或类、添加注释等。

在执行本练习之前，让我们先安装必要的软件包并设置环境

练习 0：安装和设置环境

您需要下载并安装以下软件包来设置环境以执行本练习。

• dotnet-sdk-8.0

1.  打开 Edge 浏览器。

![](./media/image1.jpeg)

2.  在浏览器 URL 字段中，复制粘贴链接以将软件包下载到实验室 VM。

dotnet-sdk-8.0
◊ https://dotnet.microsoft.com/en-us/download/dotnet/thank-you/sdk-8.0.401-windows-x64-installer

**注意：**默认情况下，包将保存在**downloads **文件夹中。

![](./media/image2.jpeg)

3.  安装 .NET SDK：转到 **Downloads** (**C:\Users\Admin\Downloads**)
    “文件夹，双击 **dotnet-sdk-8.0.401**，然后按照安装过程进行作。

![](./media/image3.jpeg)

**练习 1：在 VS Code 中设置项目**

1.  从“**Start”**菜单打开 **Visual Studio Code**。

![](./media/image4.png)

2.  选择 **File** -\> **Open Folder…**

![](./media/image5.png)

3.  从 **C：\Labfiles 中**选择 **CopilotHackathon**
    文件夹，然后单击**“Select Folder”**。

![](./media/image6.png)

4.  点击 **Yes, I trust the authors**。

![](./media/image7.png)

**练习 2：简介**

**注意：**Copilot
生成的代码在不同的执行中可能有所不同。在下面涉及代码生成的步骤中，我们给出了**Reference
code**。请使用它来交叉检查 Copilot
生成的代码的正确性或解决错误（如果有）。

1.  从 **dotnet** -\> **MinimalAPI** 打开**Program.cs**。

![](./media/image8.png)

2.  在 **MinimalAPI\Program.cs** 中，**在 ADD NEW ENDPOINTS HERE**（行号
    19） 行之后，键入 // Hello World Get endpoint，然后按
    **Enter**。Copilot 将以灰色建议代码。

![](./media/image9.png)

3.  获得 Copilot 生成的代码后，您可以接受它或丢弃它。要接受，请单击
    按**Ctrl** 按钮，选项栏将出现在灰色文本上。另一种选择是简单地按
    **Tab** 键。

**Reference code :** app.MapGet("/", () =\> "Hello World!");

![](./media/image10.png)

4.  代码现在将如下所示。 **保存**文件。

![](./media/image11.png)

5.  右键单击 **dotnet** 文件夹，然后选择**“Open in Integrated
    Terminal”**。

![](./media/image12.png)

6.  在终端中，执行以下命令。

dotnet test

![](./media/image13.png)

**练习 3：构建新功能**

1.  在 Hello World 终结点旁边，添加 **DaysBetweenDates。**

2.  按 **Ctrl+I** 以内联打开 Copilot。

3.  输入以下文本并点击 **Send** 按钮。

4.  /DaysBetweenDates:

5.  计算两个日期之间的天数

通过查询字符串接收两个参数 date1 和 date2，并计算这两个日期之间的天数。

![](./media/image14.png)

6.  Copilot 现在生成 **code** 并将其输入到 **Program.cs**
    文件中。完成后，您将看到两个选项 **Accept** 或
    **Discard**。**接受**代码。 

![](./media/image15.png)

7.  接受后，选择生成的代码并按 **Ctrl+I。**
    输入，将此代码转换为单行，然后按 **Enter**。单击 接受
    一旦代码转换为单行。

**Reference
code** - app.MapGet("/DaysBetweenDates", (DateTime date1, DateTime date2) =\> (date2 - date1).Days.ToString());

![](./media/image16.png)

8.  输入以下语句（已注释），然后单击 **Enter**。

Click on Accept to accept the code generated by the Copilot.

/\*

/validatephonenumber:

receive by querystring a parameter called phoneNumber

validate phoneNumber with Spanish format, for example +34666777888

if phoneNumber is valid return true

\*/

**Reference code:**

app.MapGet("/validatephonenumber", (string phonenumber) =\> Regex.IsMatch(phonenumber, @"^(\\\[0-9\]{9})\$").ToString());

![](./media/image17.png)

9.  在 Program.cs 文件中添加以下文本，如 Copilot 内联功能中，然后按
    **Enter**。

10. /validatespanishdni:

11. receive by querystring a parameter called dni

12. calculate DNI letter

13. if DNI is valid return "valid"

如果 DNI 无效，则返回“invalid”

在这种情况下，您可能希望查看 Copilot
中的多个解决方案，以选择最适合计算字母方式的解决方案。要查看 Copilot 的
10 条建议，请按 ctrl + enter。

接受 GitHub 生成的代码。

**Reference Code:**

app.MapGet("/validatespanishdni", (string dni) =\> {

var valid = false;

if (dni.Length == 9 && int.TryParse(dni.Substring(0, 8), out int
number))

{

var letters = "TRWAGMYFPDXBNJZSQVHLCKE";

var letter = letters\[number % 23\];

valid = dni.EndsWith(letter.ToString());

}

return valid ? "valid" : "invalid";

});

![](./media/image18.png)

14. 从 左窗格中选择 **Chat **。

![](./media/image19.png)

15. 输入以下文本，然后单击 **Enter**。

16. /returncolorcode:

receive by querystring a parameter called color read colors.json file
and return the rgba field get color var from querystring iterate for
each color in colors.json to find the color return the code.hex field

![](./media/image20.png)

17. 查看 Copilot 给出了详细的步骤，然后是生成的**代码**。将光标放在
    Program.cs 文件中，在 **validatespanishdni** 代码之后。单击“**Insert
    at cursor ”图标**将代码粘贴到文件中。

**Reference Code:**

app.MapGet("/color", (string color) =\>

{

var colors =
JsonSerializer.Deserialize\<Color\[\]\>(File.ReadAllText("colors.json"));

return colors.First(c =\> c.Name == color).Code.HEX;

});

![](./media/image21.png)

![](./media/image22.png)

18. 确保生成的代码中没有错误。如果存在错误，请保留参考代码作为参考并更正代码。

19. 在这种情况下，存在错误，**Color does not contain definition for
    code**。

![](./media/image23.png)

20. 生成的代码更新如下以解决错误。

![](./media/image24.png)

21. 输入以下文本，然后按 Enter 并查看并接受 Copilot 生成的代码。

22. /\*

23. /tellmeajoke:

24. Make a call to the joke api and return a random joke

\*/

**Reference code:**

app.MapGet("/tellmeajoke", async () =\> {

var client = new HttpClient();

var response = await
client.GetAsync("https://official-joke-api.appspot.com/jokes/random");

var joke = await response.Content.ReadAsStringAsync();

return joke;

});

![](./media/image25.png)

注意：这是一个示例，您可能需要使用自己的知识和判断来验证 Copilot
是否遵循最佳实践。仅仅因为 Copilot
模仿了许多开发人员所做的事情，并不总是意味着它是正确的方法。您可能需要在提示中更加具体，让
Copilot 知道最佳做法是什么。提示：注意 HttpClient。

25. Copilot 可以帮助您学习新框架。

在 Copilot 中输入以下文本，然后按 **Enter**。

/parseurl:

Retrieves a parameter from querystring called someurl

Parse the url and return the protocol, host, port, path, querystring and
hash

Return the parsed host

**Reference code:**

app.MapGet("/parseurl", (string someurl) =\> {

var uri = new Uri(someurl);

var host = uri.Host;

var protocol = uri.Scheme;

var port = uri.Port;

var path = uri.AbsolutePath;

var query = uri.Query;

var hash = uri.Fragment;

return host;

});

![](./media/image26.png)

26. Copilot 还可以在本地帮助处理此类命令。该功能在 CLI 中称为
    Copilot。您可以在此处了解有关此功能的更多信息。

打开 Copilot Inline，输入以下文本并按 **Enter**。

/listfiles:

Get the current directory

Get the list of files in the current directory

Return the list of files

**Reference code:**

app.MapGet("/listfiles", () =\> {

var currentDirectory = Directory.GetCurrentDirectory();

var files = Directory.GetFiles(currentDirectory);

return files;

});

![](./media/image27.png)

27. 在内联助手中输入以下文本，然后按 **Enter**。

28. /calculatememoryconsumption:

返回进程的内存消耗（以 GB 为单位），四舍五入为 2 位小数

**Reference code:**

// Calculate memory consumption endpoint

app.MapGet("/calculatememoryconsumption", () =\>

{

var process = System.Diagnostics.Process.GetCurrentProcess();

var memoryUsage = process.WorkingSet64 / (1024.0 \* 1024 \* 1024); //
Convert to GB

return Math.Round(memoryUsage, 2);

});

![](./media/image28.png)

29. 在 Copilot 中输入以下文本，然后按 **Enter**。

30. /randomeuropeancountry:

31. 制作一系列欧洲国家及其 ISO 代码

32. 从数组中返回一个随机国家/地区

返回国家/地区及其 iso 代码

**Reference code:**

// Random European Country endpoint

app.MapGet("/randomeuropeancountry", () =\>

{

var europeanCountries = new Dictionary\<string, string\>

{

{ "Albania", "AL" },

{ "Andorra", "AD" },

{ "Austria", "AT" },

{ "Belarus", "BY" },

{ "Belgium", "BE" },

{ "Bosnia and Herzegovina", "BA" },

{ "Bulgaria", "BG" },

{ "Croatia", "HR" },

{ "Cyprus", "CY" },

{ "Czech Republic", "CZ" },

{ "Denmark", "DK" },

{ "Estonia", "EE" },

{ "Finland", "FI" },

{ "France", "FR" },

{ "Germany", "DE" },

{ "Greece", "GR" },

{ "Hungary", "HU" },

{ "Iceland", "IS" },

{ "Ireland", "IE" },

{ "Italy", "IT" },

{ "Kosovo", "XK" },

{ "Latvia", "LV" },

{ "Liechtenstein", "LI" },

{ "Lithuania", "LT" },

{ "Luxembourg", "LU" },

{ "Malta", "MT" },

{ "Moldova", "MD" },

{ "Monaco", "MC" },

{ "Montenegro", "ME" },

{ "Netherlands", "NL" },

{ "North Macedonia", "MK" },

{ "Norway", "NO" },

{ "Poland", "PL" },

{ "Portugal", "PT" },

{ "Romania", "RO" },

{ "Russia", "RU" },

{ "San Marino", "SM" },

{ "Serbia", "RS" },

{ "Slovakia", "SK" },

{ "Slovenia", "SI" },

{ "Spain", "ES" },

{ "Sweden", "SE" },

{ "Switzerland", "CH" },

{ "Ukraine", "UA" },

{ "United Kingdom", "GB" },

{ "Vatican City", "VA" }

};

var random = new Random();

var index = random.Next(europeanCountries.Count);

var country = europeanCountries.ElementAt(index);

return \$"{country.Key} ({country.Value})";

});

![](./media/image29.png)

**练习 4：记录代码**

1.  打开chat窗口。

![](./media/image19.png)

2.  键入，**Document the Program.cs file** ，然后选择 **Send**。

GitHubCopiot 生成**Program.cs**文件的简短**文档**。

![](./media/image30.png)

**练习 5：构建测试**

1.  打开**Program.cs**文件。

2.  选择 **DaysBetweenDates** 终结点，按 **Ctrl+I** 内联打开 Copilot。

在 Copilot 内联中，键入 **/tests** 并单击“**Send”**按钮。

![](./media/image31.png)

3.  复制生成的测试。

![](./media/image32.png)

4.  从 MinimalAPI.Tests 打开IntegrationTests.cs。

![](./media/image33.png)

5.  将其粘贴到 cs 文件中，在 Hello World
    的测试块之后。解决可能出现的任何问题。

6.  从左窗格打开 Copilot 聊天。

![](./media/image19.png)

7.  键入 /tests，创建测试单元的命令，然后按 **Enter**。Copilot
    生成一个测试文件。复制其内容。

![](./media/image34.png)

![](./media/image35.png)

8.  从 **MinimalAPI.Tests** 打开**IntegrationTests.cs**。

![](./media/image33.png)

9.  将文件的内容替换为 Copilot 生成的代码并保存。

**重要提示：**检查是否有任何错误并使用 /fix
命令或手动修复它。使用下面的参考代码进行故障排除。

10. 如果未为所有终结点生成测试，请在聊天中指定终结点名称并要求 Copilot
    生成测试，如下所示。根据测试中更新的终结点名称和缺失的终结点名称。

generate test units for moviesbydirector, parseurl, listfiles,
calculatememoryconsumption and randomeuropeancountry

**Reference Code:**

using System;

using System.Net.Http;

using System.Threading.Tasks;

using Microsoft.AspNetCore.Mvc.Testing;

using Xunit;

public class EndpointTests :
IClassFixture\<WebApplicationFactory\<Program\>\>

{

private readonly WebApplicationFactory\<Program\> \_factory;

private readonly HttpClient \_client;

public EndpointTests(WebApplicationFactory\<Program\> factory)

{

\_factory = factory;

\_client = \_factory.CreateClient();

}

\[Fact\]

public async Task Get_HelloWorld_ReturnsHelloWorld()

{

var response = await \_client.GetAsync("/");

response.EnsureSuccessStatusCode();

var stringResponse = await response.Content.ReadAsStringAsync();

Assert.Equal("Hello World!", stringResponse);

}

\[Fact\]

public async Task Get_ValidatePhoneNumber_ReturnsInvalid()

{

var response = await
\_client.GetAsync("/validatephonenumber?phonenumber=123456789");

response.EnsureSuccessStatusCode();

var stringResponse = await response.Content.ReadAsStringAsync();

Assert.Equal("False", stringResponse);

}

\[Fact\]

public async Task Get_ValidateSpanishDni_ReturnsValid()

{

var response = await
\_client.GetAsync("/validatespanishdni?dni=12345678Z");

response.EnsureSuccessStatusCode();

var stringResponse = await response.Content.ReadAsStringAsync();

Assert.Equal("valid", stringResponse);

}

\[Fact\]

public async Task Get_Color_ReturnsHexCode()

{

var response = await \_client.GetAsync("/color?color=red");

response.EnsureSuccessStatusCode();

var stringResponse = await response.Content.ReadAsStringAsync();

Assert.Equal("#FF0000", stringResponse); // assuming red color returns
\#FF0000

}

\[Fact\]

public async Task Get_TellMeAJoke_ReturnsJoke()

{

var response = await \_client.GetAsync("/tellmeajoke");

response.EnsureSuccessStatusCode();

var stringResponse = await response.Content.ReadAsStringAsync();

Assert.NotNull(stringResponse); // assuming the joke API always returns
a joke

}

\[Fact\]

public async Task Get_ParseUrl_ReturnsHost()

{

var response = await
\_client.GetAsync("/parseurl?someurl=https://www.example.com");

response.EnsureSuccessStatusCode();

var stringResponse = await response.Content.ReadAsStringAsync();

Assert.Equal("www.example.com", stringResponse);

}

\[Fact\]

public async Task Get_ListFiles_ReturnsFiles()

{

var response = await \_client.GetAsync("/listfiles");

response.EnsureSuccessStatusCode();

var stringResponse = await response.Content.ReadAsStringAsync();

Assert.NotNull(stringResponse); // assuming the API always returns a
list of files

}

\[Fact\]

public async Task Get_CalculateMemoryConsumption_ReturnsMemoryUsage()

{

var response = await \_client.GetAsync("/calculatememoryconsumption");

response.EnsureSuccessStatusCode();

var stringResponse = await response.Content.ReadAsStringAsync();

Assert.NotNull(stringResponse); // assuming the API always returns a
memory usage

}

\[Fact\]

public async Task Get_RandomEuropeanCountry_ReturnsCountry()

{

var response = await \_client.GetAsync("/randomeuropeancountry");

response.EnsureSuccessStatusCode();

var stringResponse = await response.Content.ReadAsStringAsync();

Assert.NotNull(stringResponse); // assuming the API always returns a
country

}

// Add similar tests for the other endpoints

}

![](./media/image36.png)

11. 在终端中，执行命令 **dotnet test**

12. 如果测试通过，您应该会看到类似于以下屏幕截图中的输出。

![](./media/image37.png)

13. 如果需要，您可以添加更多测试。

**练习 6：创建 Dockerfile**

1.  右键单击 **dotnet** 文件夹，然后选择“**New File**”，并将该文件命名为
    **Dockerfile**。

![](./media/image38.png)

2.  将文件命名为 **Dockerfile**。

![](./media/image39.png)

3.  在新创建的文件中，按 **Ctrl+I**，键入以下文本，然后按 **Enter**。

**Generate content for Dockerfile for .NET 8 Project Name - MinimalAPI**

![](./media/image40.png)

4.  接受生成的代码。

![](./media/image41.png)

5.  保存文件。在终端中，执行以下命令。

docker build -t dotnetapp .

使用参考代码解决错误（如果有）。

**Reference Code:**

\# Use the official .NET SDK image as the base image

FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build

\# Set the working directory in the container

WORKDIR /app

\# Copy the project file(s) to the container

COPY \*.csproj ./

\# Copy the remaining source code to the container

COPY . ./

\# Build the application

RUN dotnet build -c Release

\# Publish the application

RUN dotnet publish -c Release --no-build -o out

\# Use the official .NET runtime image as the base image for the final
stage

FROM mcr.microsoft.com/dotnet/runtime:8.0 AS runtime

\# Set the working directory in the container

WORKDIR /app

\# Copy the published output from the build stage to the final stage

COPY --from=build /app/out ./

\# Set the entry point for the container

ENTRYPOINT \["dotnet", "MinimalAPI.dll"\]

![](./media/image42.png)

6.  执行以下命令在端口 8080 上运行应用程序

docker run -d -p 8080:80 --name dotnetapp dotnetapp

![](./media/image43.png)

7.  现在，我们在 docker 中运行了 dotnet 应用程序。

![](./media/image44.png)

